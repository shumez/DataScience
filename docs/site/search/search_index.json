{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project_layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"PythonDataScienceHandbook/","text":"Python Data Science Handbook \u00b6 Contents \u00b6 IPython: Beyond Normal Python Introduction to Numpy Data Manipulation with Pandas Visualization with Matplotlib Machine Learning","title":"Intro"},{"location":"PythonDataScienceHandbook/#contents","text":"IPython: Beyond Normal Python Introduction to Numpy Data Manipulation with Pandas Visualization with Matplotlib Machine Learning","title":"Contents"},{"location":"PythonDataScienceHandbook/02/","text":"02. Introduction to Numpy \u00b6 Contents \u00b6 02.01. Understanding Data Types in Python 02.01.01. A Python Interger Is More Than Just an Integer 02.01.02. A Python List Is More Than Just a List 02.01.03. Fixed-Type Arrays in Python 02.01.04. Creating Arrays from Python Lists 02.01.05. Creating Arrays from Scratch 02.01.06. NumPy Standard Data Types 02.02. The Basics of Numpy Arrays 02.02.01. NumPy Array Attributes 02.02.02. Array Indexing: Accessing Single Elements 02.02.03. Array Slicing: Accessing Subarrays 02.02.03.01. One-dimensional subarrays 02.02.03.02. Multidimensional subarrays 02.02.03.03. Accessing array rows and columns 02.02.03.04. Subarrays as no-copy views 02.02.03.05. Creating copies of arrays 02.02.04. Reshaping of Arrays 02.02.05. Array Concatenation and Splitting 02.02.05.01. Concatenation of arrays 02.02.05.02. Splitting of arrays 02.03. Computation on Numpy Arrays: Universal Functions 02.03.01. The Slowness of Loops 02.03.02. Introducing UFuncs 02.03.03. Exploring NumPy's UFuncs 02.03.03.01. Array arithmetic 02.03.03.02. Absolute value 02.03.03.03. Trigometric functions 02.03.03.04. Exponents and logarithms 02.03.03.05. Specialized ufuncs 02.03.04. Advanced Ufunc Features 02.03.04.01. Specifying output 02.03.04.02. Aggregates 02.03.04.03. Outer products 02.03.05. Ufuncs: Leanging More 02.04. Aggregations: Min, Max, and Everything in Between 02.04.01. Summing the Values in an Array 02.04.02. Minimum and Maximum 02.04.02.01. Multidimensional aggregates 02.04.02.02. Other aggregation functions 02.04.03. Example: What Is the Average Height of US Presidents? 02.05. Computation on Arrays: Broadcasting 02.05.01. Introducing Broadcasting 02.05.02. Rules of Broadcasting 02.05.02.01. Broadcasting example 1 02.05.02.02. Broadcasting example 2 02.05.02.03. Broadcasting example 3 02.05.03. Broadcasting in Practice 02.05.03.01. Centering an array 02.05.03.02. Plotting a two-dimensional function 02.06. Comparisons, Masks, and Boolean Logic 02.06.01. Example: Counting Rainy Days 02.06.01.01. Digging into the data 02.06.02. Comparison Operators as ufuncs 02.06.03. Working with Boolean Arrays 02.06.03.01. Counting entries 02.06.03.02. Boolean operators 02.06.04. Boolean Arrays as Masks 02.07. Fancy Indexing 02.07.01. Exploring Fancy Indexing 02.07.02. Combined Indexing 02.07.03. Example: Selecting Random Points 02.07.04. Modifying Values with Fancy Indexing 02.07.05. Example: Binning Data 02.08. Sorting Arrays 02.08.01. Fast Sorting in Numpy: np.sort and np.argsort 02.08.01.01. Sorting along rows or columns 02.08.02. Partial Sorts: Partitioning 02.09. Structured Data: NumPy's Structured Arrays 02.01. Understanding Data Types in Python \u00b6 02.01.01. A Python Interger Is More Than Just an Integer \u00b6 02.01.02. A Python List Is More Than Just a List \u00b6 L = list(range(10)) L2 = [str(c) for c in L] 02.01.03. Fixed-Type Arrays in Python \u00b6 import array L = list(range(10)) A = array.array('i', L) 02.01.04. Creating Arrays from Python Lists \u00b6 02.01.05. Creating Arrays from Scratch \u00b6 02.01.06. NumPy Standard Data Types \u00b6 02.02. The Basics of Numpy Arrays \u00b6 Attributes of arrays Indexing of arrays Slicing of arrrays Reshaping of arrays Joining and splitting of arrays 02.02.01. NumPy Array Attributes \u00b6 02.02.02. Array Indexing: Accessing Single Elements \u00b6 02.02.03. Array Slicing: Accessing Subarrays \u00b6 x[start:stop:step] 02.02.03.01 One-dimensional subarrays \u00b6 x[1::2] > [1 3 5 7 9] x[5::-2] > [5 3 1] 02.02.03.02 Multidimensional subarrays \u00b6 02.02.03.03 Accessing array rows and columns \u00b6 02.02.03.04 Subarrays as no-copy views \u00b6 x2_sub = x2[:2, :2] x2_sub[0, 0] = 99 x2 original array is changed 02.02.03.05 Creating copies of arrays \u00b6 x2_sub_copy = x2[:2, :2].copy() original array is NOT changed 02.02.04. Reshaping of Arrays \u00b6 # via reshape x.reshape((3, 1)) # via newaxis x[:, np.newaxis] 02.02.05. Array Concatenation and Splitting \u00b6 02.02.05.01. Concatenation of arrays \u00b6 x = np.array([1, 2, 3]) grid = np.array([[9, 8, 7], [6, 5, 4]]) np.vstack([x, grid]) y = np.array([[99], [99]]) np.hstack([grid, y]) z = np.array([[-2, -1, 0], [-5, -4, -3]]) np.dstack([grid, z]) 02.02.05.02. Splitting of arrays \u00b6 02.03. Computation on NumPy Arrays: Universal Functions \u00b6 02.03.01. The Slowness of Loops \u00b6 CPython (Python's default implementation) very slowly PyPy : just-in-time compiled implementation of Python Cython : convert Python to C Numba : convert Python to LLVM bytecode 02.03.02. Introducing UFuncs \u00b6 NumPy are implemented via ufunc 02.03.03. Exploring NumPy's UFuncs \u00b6 unary ufuncs binary ufuncs 02.03.03.01. Array arithmetic \u00b6 np.add(x, 5) np.subtract(x, 5) np.negative(x) np.multiply(x, 2) np.divide(x, 2) np.floor_divide(x, 2) np.power(x, 2) np.mod(x, 2) operator ufunc + np.add - np.subtract - np.negative * np.multiple / np.divide // np.floor_divide ** np.power % np.mod 02.03.03.02. Absolute value \u00b6 02.03.03.03. Trigometric functions \u00b6 02.03.03.04. Exponents and logarithms \u00b6 02.03.03.05. Specialized ufuncs \u00b6 02.03.04. Advanced Ufunc Features \u00b6 02.03.04.01. Specifying output \u00b6 n = 100000000 x = np.arange(n) y = np.zeros(n*2) %timeit y[::2] = 2 ** x %timeit np.power(2, x, out=y[::2]) 14.2 s \u00b1 902 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) 12.3 s \u00b1 613 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) 02.03.04.02. Aggregates \u00b6 np.add.reduce(x) np.multiply.reduce(x) np.add.accumulate(x) np.multiply.accumulate(x) 02.03.04.03. Outer products \u00b6 np.multiply.outer(x, x) 02.03.05 Ufuncs: Leanging More \u00b6 02.04. Aggregations: Min, Max, and Everything in Between \u00b6 02.04.01. Summing the Values in an Array \u00b6 sum(x) np.sum(x) 02.04.02. Minimum and Maximum \u00b6 min(x) np.min(x) 02.04.02.01. Multidimensional aggregates \u00b6 M.sum(axis=0) M.max(axis=0) M.min(axis=1) 02.04.02.02. Other aggregation functions \u00b6 02.04.03. Example: What Is the Average Height of US Presidents? \u00b6 02.05. Computation on Arrays: Broadcasting \u00b6 02.05.01. Introducing Broadcasting \u00b6 02.05.02. Rules of Broadcasting \u00b6 02.05.02.01. Broadcasting example 1 \u00b6 02.05.02.02. Broadcasting example 2 \u00b6 02.05.02.03. Broadcasting example 3 \u00b6 02.05.03. Broadcasting in Practice \u00b6 02.05.03.01. Centering an array \u00b6 02.05.03.02. Plotting a two-dimensional function \u00b6 02.06. Comparisons, Masks, and Boolean Logic \u00b6 02.06.01. Example: Counting Rainy Days \u00b6 02.06.01.01. Digging into the data \u00b6 02.06.02. Comparison Operators as ufuncs \u00b6 operator ufunc == np.equal != np.not_equal < np.less <= np.less_equal > np.greater >= np.greater_equal 02.06.03. Working with Boolean Arrays \u00b6 02.06.03.01. Counting entries \u00b6 np.count_nonzero(x < 6) np.sum(x < 6) np.sum(x < 6, axis=1) 02.06.03.02. Boolean operators \u00b6 operator ufunc & np.bitwise_and | np.bitwise_or ^ np.bitwise_xor ~ np.bitwise_not 02.06.04. Boolean Arrays as Masks \u00b6 x < 5 x[x < 5] 02.07. Fancy Indexing \u00b6 simple indices arr[0] slices arr[:5] Boolean masks arr[arr > 0] fancy indexing 02.07.01. Exploring Fancy Indexing \u00b6 ind = np.array([[3, 7], [4, 5]]) x[ind] > [[71 86] [60 20]] X = np.arange(12).reshape((3, 4)) row = np.array([0, 1, 2]) col = np.array([2, 1, 3]) X[row, col] > [ 2 5 11] X[row[:, np.newaxis], col] > [[ 2 1 3] [ 6 5 7] [10 9 11]] 02.07.02. Combined Indexing \u00b6 02.07.03. Example: Selecting Random Points \u00b6 02.07.04. Modifying Values with Fancy Indexing \u00b6 02.07.05. Example: Binning Data \u00b6 02.08. Sorting Arrays \u00b6 def selection_sort(x): for i in range(len(x)): swap = i + np.argmin(x[i:]) (x[i], x[swap]) = (x[swap], x[i]) return x def bogosort(x): while np.any(x[:-1] > x[1:]): np.random.shuffle(x) return x 02.08.01. Fast Sorting in Numpy: np.sort and np.argsort \u00b6 np.sort(x) x.sort() x = np.array([2, 1, 4, 3, 5]) i = np.argsort(x) x[i] 02.08.01.01. Sorting along rows or columns \u00b6 rand = np.random.RandomState(42) X = rand.randint(0, 10, (4, 6)) np.sort(X, axis=0) np.sort(X, axis=1) 02.08.02. Partial Sorts: Partitioning \u00b6 \u00b6","title":"02"},{"location":"PythonDataScienceHandbook/02/#contents","text":"02.01. Understanding Data Types in Python 02.01.01. A Python Interger Is More Than Just an Integer 02.01.02. A Python List Is More Than Just a List 02.01.03. Fixed-Type Arrays in Python 02.01.04. Creating Arrays from Python Lists 02.01.05. Creating Arrays from Scratch 02.01.06. NumPy Standard Data Types 02.02. The Basics of Numpy Arrays 02.02.01. NumPy Array Attributes 02.02.02. Array Indexing: Accessing Single Elements 02.02.03. Array Slicing: Accessing Subarrays 02.02.03.01. One-dimensional subarrays 02.02.03.02. Multidimensional subarrays 02.02.03.03. Accessing array rows and columns 02.02.03.04. Subarrays as no-copy views 02.02.03.05. Creating copies of arrays 02.02.04. Reshaping of Arrays 02.02.05. Array Concatenation and Splitting 02.02.05.01. Concatenation of arrays 02.02.05.02. Splitting of arrays 02.03. Computation on Numpy Arrays: Universal Functions 02.03.01. The Slowness of Loops 02.03.02. Introducing UFuncs 02.03.03. Exploring NumPy's UFuncs 02.03.03.01. Array arithmetic 02.03.03.02. Absolute value 02.03.03.03. Trigometric functions 02.03.03.04. Exponents and logarithms 02.03.03.05. Specialized ufuncs 02.03.04. Advanced Ufunc Features 02.03.04.01. Specifying output 02.03.04.02. Aggregates 02.03.04.03. Outer products 02.03.05. Ufuncs: Leanging More 02.04. Aggregations: Min, Max, and Everything in Between 02.04.01. Summing the Values in an Array 02.04.02. Minimum and Maximum 02.04.02.01. Multidimensional aggregates 02.04.02.02. Other aggregation functions 02.04.03. Example: What Is the Average Height of US Presidents? 02.05. Computation on Arrays: Broadcasting 02.05.01. Introducing Broadcasting 02.05.02. Rules of Broadcasting 02.05.02.01. Broadcasting example 1 02.05.02.02. Broadcasting example 2 02.05.02.03. Broadcasting example 3 02.05.03. Broadcasting in Practice 02.05.03.01. Centering an array 02.05.03.02. Plotting a two-dimensional function 02.06. Comparisons, Masks, and Boolean Logic 02.06.01. Example: Counting Rainy Days 02.06.01.01. Digging into the data 02.06.02. Comparison Operators as ufuncs 02.06.03. Working with Boolean Arrays 02.06.03.01. Counting entries 02.06.03.02. Boolean operators 02.06.04. Boolean Arrays as Masks 02.07. Fancy Indexing 02.07.01. Exploring Fancy Indexing 02.07.02. Combined Indexing 02.07.03. Example: Selecting Random Points 02.07.04. Modifying Values with Fancy Indexing 02.07.05. Example: Binning Data 02.08. Sorting Arrays 02.08.01. Fast Sorting in Numpy: np.sort and np.argsort 02.08.01.01. Sorting along rows or columns 02.08.02. Partial Sorts: Partitioning 02.09. Structured Data: NumPy's Structured Arrays","title":"Contents"},{"location":"PythonDataScienceHandbook/02/#0201_understanding_data_types_in_python","text":"","title":"02.01. Understanding Data Types in Python"},{"location":"PythonDataScienceHandbook/02/#020101_a_python_interger_is_more_than_just_an_integer","text":"","title":"02.01.01. A Python Interger Is More Than Just an Integer"},{"location":"PythonDataScienceHandbook/02/#020102_a_python_list_is_more_than_just_a_list","text":"L = list(range(10)) L2 = [str(c) for c in L]","title":"02.01.02. A Python List Is More Than Just a List"},{"location":"PythonDataScienceHandbook/02/#020103_fixed-type_arrays_in_python","text":"import array L = list(range(10)) A = array.array('i', L)","title":"02.01.03. Fixed-Type Arrays in Python"},{"location":"PythonDataScienceHandbook/02/#020104_creating_arrays_from_python_lists","text":"","title":"02.01.04. Creating Arrays from Python Lists"},{"location":"PythonDataScienceHandbook/02/#020105_creating_arrays_from_scratch","text":"","title":"02.01.05. Creating Arrays from Scratch"},{"location":"PythonDataScienceHandbook/02/#020106_numpy_standard_data_types","text":"","title":"02.01.06. NumPy Standard Data Types"},{"location":"PythonDataScienceHandbook/02/#0202_the_basics_of_numpy_arrays","text":"Attributes of arrays Indexing of arrays Slicing of arrrays Reshaping of arrays Joining and splitting of arrays","title":"02.02. The Basics of Numpy Arrays"},{"location":"PythonDataScienceHandbook/02/#020201_numpy_array_attributes","text":"","title":"02.02.01. NumPy Array Attributes"},{"location":"PythonDataScienceHandbook/02/#020202_array_indexing_accessing_single_elements","text":"","title":"02.02.02. Array Indexing: Accessing Single Elements"},{"location":"PythonDataScienceHandbook/02/#020203_array_slicing_accessing_subarrays","text":"x[start:stop:step]","title":"02.02.03. Array Slicing: Accessing Subarrays"},{"location":"PythonDataScienceHandbook/02/#02020301_one-dimensional_subarrays","text":"x[1::2] > [1 3 5 7 9] x[5::-2] > [5 3 1]","title":"02.02.03.01 One-dimensional subarrays"},{"location":"PythonDataScienceHandbook/02/#02020302_multidimensional_subarrays","text":"","title":"02.02.03.02 Multidimensional subarrays"},{"location":"PythonDataScienceHandbook/02/#02020303_accessing_array_rows_and_columns","text":"","title":"02.02.03.03 Accessing array rows and columns"},{"location":"PythonDataScienceHandbook/02/#02020304_subarrays_as_no-copy_views","text":"x2_sub = x2[:2, :2] x2_sub[0, 0] = 99 x2 original array is changed","title":"02.02.03.04 Subarrays as no-copy views"},{"location":"PythonDataScienceHandbook/02/#02020305_creating_copies_of_arrays","text":"x2_sub_copy = x2[:2, :2].copy() original array is NOT changed","title":"02.02.03.05 Creating copies of arrays"},{"location":"PythonDataScienceHandbook/02/#020204_reshaping_of_arrays","text":"# via reshape x.reshape((3, 1)) # via newaxis x[:, np.newaxis]","title":"02.02.04. Reshaping of Arrays"},{"location":"PythonDataScienceHandbook/02/#020205_array_concatenation_and_splitting","text":"","title":"02.02.05. Array Concatenation and Splitting"},{"location":"PythonDataScienceHandbook/02/#02020501_concatenation_of_arrays","text":"x = np.array([1, 2, 3]) grid = np.array([[9, 8, 7], [6, 5, 4]]) np.vstack([x, grid]) y = np.array([[99], [99]]) np.hstack([grid, y]) z = np.array([[-2, -1, 0], [-5, -4, -3]]) np.dstack([grid, z])","title":"02.02.05.01. Concatenation of arrays"},{"location":"PythonDataScienceHandbook/02/#02020502_splitting_of_arrays","text":"","title":"02.02.05.02. Splitting of arrays"},{"location":"PythonDataScienceHandbook/02/#0203_computation_on_numpy_arrays_universal_functions","text":"","title":"02.03. Computation on NumPy Arrays: Universal Functions"},{"location":"PythonDataScienceHandbook/02/#020301_the_slowness_of_loops","text":"CPython (Python's default implementation) very slowly PyPy : just-in-time compiled implementation of Python Cython : convert Python to C Numba : convert Python to LLVM bytecode","title":"02.03.01. The Slowness of Loops"},{"location":"PythonDataScienceHandbook/02/#020302_introducing_ufuncs","text":"NumPy are implemented via ufunc","title":"02.03.02. Introducing UFuncs"},{"location":"PythonDataScienceHandbook/02/#020303_exploring_numpys_ufuncs","text":"unary ufuncs binary ufuncs","title":"02.03.03. Exploring NumPy's UFuncs"},{"location":"PythonDataScienceHandbook/02/#02030301_array_arithmetic","text":"np.add(x, 5) np.subtract(x, 5) np.negative(x) np.multiply(x, 2) np.divide(x, 2) np.floor_divide(x, 2) np.power(x, 2) np.mod(x, 2) operator ufunc + np.add - np.subtract - np.negative * np.multiple / np.divide // np.floor_divide ** np.power % np.mod","title":"02.03.03.01. Array arithmetic"},{"location":"PythonDataScienceHandbook/02/#02030302_absolute_value","text":"","title":"02.03.03.02. Absolute value"},{"location":"PythonDataScienceHandbook/02/#02030303_trigometric_functions","text":"","title":"02.03.03.03. Trigometric functions"},{"location":"PythonDataScienceHandbook/02/#02030304_exponents_and_logarithms","text":"","title":"02.03.03.04. Exponents and logarithms"},{"location":"PythonDataScienceHandbook/02/#02030305_specialized_ufuncs","text":"","title":"02.03.03.05. Specialized ufuncs"},{"location":"PythonDataScienceHandbook/02/#020304_advanced_ufunc_features","text":"","title":"02.03.04. Advanced Ufunc Features"},{"location":"PythonDataScienceHandbook/02/#02030401_specifying_output","text":"n = 100000000 x = np.arange(n) y = np.zeros(n*2) %timeit y[::2] = 2 ** x %timeit np.power(2, x, out=y[::2]) 14.2 s \u00b1 902 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) 12.3 s \u00b1 613 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)","title":"02.03.04.01. Specifying output"},{"location":"PythonDataScienceHandbook/02/#02030402_aggregates","text":"np.add.reduce(x) np.multiply.reduce(x) np.add.accumulate(x) np.multiply.accumulate(x)","title":"02.03.04.02. Aggregates"},{"location":"PythonDataScienceHandbook/02/#02030403_outer_products","text":"np.multiply.outer(x, x)","title":"02.03.04.03. Outer products"},{"location":"PythonDataScienceHandbook/02/#020305_ufuncs_leanging_more","text":"","title":"02.03.05 Ufuncs: Leanging More"},{"location":"PythonDataScienceHandbook/02/#0204_aggregations_min_max_and_everything_in_between","text":"","title":"02.04. Aggregations: Min, Max, and Everything in Between"},{"location":"PythonDataScienceHandbook/02/#020401_summing_the_values_in_an_array","text":"sum(x) np.sum(x)","title":"02.04.01. Summing the Values in an Array"},{"location":"PythonDataScienceHandbook/02/#020402_minimum_and_maximum","text":"min(x) np.min(x)","title":"02.04.02. Minimum and Maximum"},{"location":"PythonDataScienceHandbook/02/#02040201_multidimensional_aggregates","text":"M.sum(axis=0) M.max(axis=0) M.min(axis=1)","title":"02.04.02.01. Multidimensional aggregates"},{"location":"PythonDataScienceHandbook/02/#02040202_other_aggregation_functions","text":"","title":"02.04.02.02. Other aggregation functions"},{"location":"PythonDataScienceHandbook/02/#020403_example_what_is_the_average_height_of_us_presidents","text":"","title":"02.04.03. Example: What Is the Average Height of US Presidents?"},{"location":"PythonDataScienceHandbook/02/#0205_computation_on_arrays_broadcasting","text":"","title":"02.05. Computation on Arrays: Broadcasting"},{"location":"PythonDataScienceHandbook/02/#020501_introducing_broadcasting","text":"","title":"02.05.01. Introducing Broadcasting"},{"location":"PythonDataScienceHandbook/02/#020502_rules_of_broadcasting","text":"","title":"02.05.02. Rules of Broadcasting"},{"location":"PythonDataScienceHandbook/02/#02050201_broadcasting_example_1","text":"","title":"02.05.02.01. Broadcasting example 1"},{"location":"PythonDataScienceHandbook/02/#02050202_broadcasting_example_2","text":"","title":"02.05.02.02. Broadcasting example 2"},{"location":"PythonDataScienceHandbook/02/#02050203_broadcasting_example_3","text":"","title":"02.05.02.03. Broadcasting example 3"},{"location":"PythonDataScienceHandbook/02/#020503_broadcasting_in_practice","text":"","title":"02.05.03. Broadcasting in Practice"},{"location":"PythonDataScienceHandbook/02/#02050301_centering_an_array","text":"","title":"02.05.03.01. Centering an array"},{"location":"PythonDataScienceHandbook/02/#02050302_plotting_a_two-dimensional_function","text":"","title":"02.05.03.02. Plotting a two-dimensional function"},{"location":"PythonDataScienceHandbook/02/#0206_comparisons_masks_and_boolean_logic","text":"","title":"02.06. Comparisons, Masks, and Boolean Logic"},{"location":"PythonDataScienceHandbook/02/#020601_example_counting_rainy_days","text":"","title":"02.06.01. Example: Counting Rainy Days"},{"location":"PythonDataScienceHandbook/02/#02060101_digging_into_the_data","text":"","title":"02.06.01.01. Digging into the data"},{"location":"PythonDataScienceHandbook/02/#020602_comparison_operators_as_ufuncs","text":"operator ufunc == np.equal != np.not_equal < np.less <= np.less_equal > np.greater >= np.greater_equal","title":"02.06.02. Comparison Operators as ufuncs"},{"location":"PythonDataScienceHandbook/02/#020603_working_with_boolean_arrays","text":"","title":"02.06.03. Working with Boolean Arrays"},{"location":"PythonDataScienceHandbook/02/#02060301_counting_entries","text":"np.count_nonzero(x < 6) np.sum(x < 6) np.sum(x < 6, axis=1)","title":"02.06.03.01. Counting entries"},{"location":"PythonDataScienceHandbook/02/#02060302_boolean_operators","text":"operator ufunc & np.bitwise_and | np.bitwise_or ^ np.bitwise_xor ~ np.bitwise_not","title":"02.06.03.02. Boolean operators"},{"location":"PythonDataScienceHandbook/02/#020604_boolean_arrays_as_masks","text":"x < 5 x[x < 5]","title":"02.06.04. Boolean Arrays as Masks"},{"location":"PythonDataScienceHandbook/02/#0207_fancy_indexing","text":"simple indices arr[0] slices arr[:5] Boolean masks arr[arr > 0] fancy indexing","title":"02.07. Fancy Indexing"},{"location":"PythonDataScienceHandbook/02/#020701_exploring_fancy_indexing","text":"ind = np.array([[3, 7], [4, 5]]) x[ind] > [[71 86] [60 20]] X = np.arange(12).reshape((3, 4)) row = np.array([0, 1, 2]) col = np.array([2, 1, 3]) X[row, col] > [ 2 5 11] X[row[:, np.newaxis], col] > [[ 2 1 3] [ 6 5 7] [10 9 11]]","title":"02.07.01. Exploring Fancy Indexing"},{"location":"PythonDataScienceHandbook/02/#020702_combined_indexing","text":"","title":"02.07.02. Combined Indexing"},{"location":"PythonDataScienceHandbook/02/#020703_example_selecting_random_points","text":"","title":"02.07.03. Example: Selecting Random Points"},{"location":"PythonDataScienceHandbook/02/#020704_modifying_values_with_fancy_indexing","text":"","title":"02.07.04. Modifying Values with Fancy Indexing"},{"location":"PythonDataScienceHandbook/02/#020705_example_binning_data","text":"","title":"02.07.05. Example: Binning Data"},{"location":"PythonDataScienceHandbook/02/#0208_sorting_arrays","text":"def selection_sort(x): for i in range(len(x)): swap = i + np.argmin(x[i:]) (x[i], x[swap]) = (x[swap], x[i]) return x def bogosort(x): while np.any(x[:-1] > x[1:]): np.random.shuffle(x) return x","title":"02.08. Sorting Arrays"},{"location":"PythonDataScienceHandbook/02/#020801_fast_sorting_in_numpy_npsort_and_npargsort","text":"np.sort(x) x.sort() x = np.array([2, 1, 4, 3, 5]) i = np.argsort(x) x[i]","title":"02.08.01. Fast Sorting in Numpy: np.sort and np.argsort"},{"location":"PythonDataScienceHandbook/02/#02080101_sorting_along_rows_or_columns","text":"rand = np.random.RandomState(42) X = rand.randint(0, 10, (4, 6)) np.sort(X, axis=0) np.sort(X, axis=1)","title":"02.08.01.01. Sorting along rows or columns"},{"location":"PythonDataScienceHandbook/02/#020802_partial_sorts_partitioning","text":"","title":"02.08.02. Partial Sorts: Partitioning"},{"location":"RForDataScience/","text":"R for Data Science \u00b6 ToC \u00b6 01. Introduction I. Explore 02. Introduction 03. Data visualization 04. Workflow: basics 05. Data transformation 06. Workflow: scripts 07. Exploratory Data Analysis 08. Workflow: projects II. Wrange 09. Introduction \u00b6 \u00b6 img{width: 51%; float: right;}","title":"Intro"},{"location":"RForDataScience/#toc","text":"01. Introduction I. Explore 02. Introduction 03. Data visualization 04. Workflow: basics 05. Data transformation 06. Workflow: scripts 07. Exploratory Data Analysis 08. Workflow: projects II. Wrange 09. Introduction","title":"ToC"}]}